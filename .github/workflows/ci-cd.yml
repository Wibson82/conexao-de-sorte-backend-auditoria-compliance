name: "ğŸ“Š Auditoria Compliance â€“ CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: "Destino do deploy"
        required: false
        default: "production"
        type: choice
        options: [ staging, production ]

# ----------------------------------------------------------------------
# PARÃ‚METROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: auditoria-compliance
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

# ----------------------------------------------------------------------
# JOB 1 â–¸ VALIDAÃ‡ÃƒO DO WORKSPACE
# ----------------------------------------------------------------------

jobs:
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python para validaÃ§Ã£o YAML (scripts)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Instalar dependÃªncias para validaÃ§Ã£o YAML (pyyaml)
        run: pip install --upgrade pip pyyaml

      - name: "Guard: validar configuraÃ§Ãµes obrigatÃ³rias (microservice)"
        shell: bash
        run: |
          chmod +x .github/workflows/scripts/validate-required-files.sh
          ./.github/workflows/scripts/validate-required-files.sh microservice auditoria-compliance

      - name: "Guard: proibir r2dbc:h2 fora de testes"
        shell: bash
        run: |
          set -euo pipefail
          FOUND=$(grep -R --line-number --include='*.yml' --include='*.yaml' --include='*.properties' "r2dbc:h2" src || true)
          if echo "$FOUND" | grep -v "src/test/" | grep -q "r2dbc:h2"; then
            echo "âŒ r2dbc:h2 encontrado fora de src/test" >&2
            echo "$FOUND" >&2
            exit 1
          fi

      - name: "Guard: dependÃªncia H2 nÃ£oâ€‘test"
        shell: bash
        run: |
          ./mvnw -q dependency:list -DincludeScope=compile -DoutputFile=deps.txt
          if grep -E "com.h2database:h2|io.r2dbc:r2dbc-h2" deps.txt; then
            echo "âŒ H2 presente em scope de produÃ§Ã£o" >&2
            exit 1
          fi


# ----------------------------------------------------------------------
# JOB 2 â–¸ BUILD + TEST + SAST/SCA
# ----------------------------------------------------------------------

  build-test-scan:
    needs: validate-environment
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 24 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "24"
          cache: maven

      # ValidaÃ§Ãµes de YAML e Docker Compose sÃ£o cobertas por
      # ./.github/workflows/scripts/validate-required-files.sh no job anterior

      - name: Build + Test + Package
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}
        run: |
          if [ -n "${NVD_API_KEY:-}" ]; then
            echo "âœ… NVD API Key configurada - varredura serÃ¡ acelerada"
            export MAVEN_OPTS="$MAVEN_OPTS -DnvdApiKey=$NVD_API_KEY"
          else
            echo "âš ï¸ NVD API Key nÃ£o configurada - varredura pode ser lenta"
          fi
          ./mvnw -B clean compile test package

      - name: Upload JAR artefact
        uses: actions/upload-artifact@v4
        with:
          name: auditoria-compliance-jar
          path: target/conexao-auditoria-compliance-*.jar
          retention-days: 1

      - name: Upload configuraÃ§Ãµes para deploy
        uses: actions/upload-artifact@v4
        with:
          name: auditoria-compliance-configs
          path: |
            docker-compose.yml
            Dockerfile
          retention-days: 1

# ----------------------------------------------------------------------
# JOB 3 â–¸ ANÃLISE DE SEGURANÃ‡A
# ----------------------------------------------------------------------

  security-analysis:
    needs: build-test-scan
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - name: Verificar score de seguranÃ§a (microservice)
        run: |
          chmod +x .github/workflows/scripts/security-analysis.sh
          ./.github/workflows/scripts/security-analysis.sh microservice 4 auditoria-compliance
# ----------------------------------------------------------------------
# JOB 3 â–¸ BUILD DA IMAGEM + PUSH GHCR
# ----------------------------------------------------------------------

  build-image:
    needs: [build-test-scan, security-analysis]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      image-uri: ${{ steps.build-and-push.outputs.image-uri }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Download JAR artefact
        uses: actions/download-artifact@v4
        with:
          name: auditoria-compliance-jar
          path: target

      - name: Download configuraÃ§Ãµes
        uses: actions/download-artifact@v4
        with:
          name: auditoria-compliance-configs
          path: .

      # â”€â”€â”€ Login no GHCR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        id: build-and-push
        run: |
          REPO_LOWERCASE=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          TIMESTAMP=$(date +'%d-%m-%Y-%H-%M')
          IMAGE_URI="ghcr.io/${REPO_LOWERCASE}/conexao-de-sorte-backend-auditoria-compliance:${TIMESTAMP}"

          echo "ğŸ—ï¸ Building and pushing Auditoria/Compliance to ${IMAGE_URI}"

          docker buildx build \
            --platform linux/amd64 \
            --push \
            --tag "${IMAGE_URI}" \
            --tag "ghcr.io/${REPO_LOWERCASE}/conexao-de-sorte-backend-auditoria-compliance:latest" \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            .
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Image built and pushed successfully"

# ----------------------------------------------------------------------
# JOB 4 â–¸ DEPLOY SELFâ€‘HOSTED (Docker Swarm + secrets)
# ----------------------------------------------------------------------

  deploy-selfhosted:
    needs: build-image
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-backend-auditoria-compliance ]
    timeout-minutes: 8
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production'))
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Login GHCR (Self-hosted)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull imagem do GHCR
        run: docker pull "${{ needs.build-image.outputs.image-uri }}"

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      - name: Sincronizar Azure Key Vault â†’ Docker Secrets (padronizado)
        shell: bash
        run: |
          set -euo pipefail
          chmod +x .github/workflows/scripts/sync-azure-keyvault-secrets.sh
          VAULT_NAME="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          ./.github/workflows/scripts/sync-azure-keyvault-secrets.sh "$VAULT_NAME" "auditoria-compliance"

      - name: Carregar variÃ¡veis de ambiente a partir do Key Vault
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          get_secret() { az keyvault secret show --vault-name "$VAULT" --name "$1" --query value -o tsv 2>/dev/null || true; }
          REDIS_HOST=$(get_secret "conexao-de-sorte-redis-host"); echo "REDIS_HOST=${REDIS_HOST:-}" >> $GITHUB_ENV
          REDIS_PORT=$(get_secret "conexao-de-sorte-redis-port"); echo "REDIS_PORT=${REDIS_PORT:-6379}" >> $GITHUB_ENV
          REDIS_PASSWORD=$(get_secret "conexao-de-sorte-redis-password"); echo "REDIS_PASSWORD=${REDIS_PASSWORD:-}" >> $GITHUB_ENV
          REDIS_DATABASE=$(get_secret "conexao-de-sorte-redis-database"); echo "REDIS_DATABASE=${REDIS_DATABASE:-1}" >> $GITHUB_ENV
          
          # Database (R2DBC/JDBC) para o serviÃ§o de Compliance
          SPRING_R2DBC_URL=$(get_secret "conexao-de-sorte-database-r2dbc-url"); echo "SPRING_R2DBC_URL=${SPRING_R2DBC_URL:-}" >> $GITHUB_ENV
          SPRING_FLYWAY_URL=$(get_secret "conexao-de-sorte-database-jdbc-url"); echo "SPRING_FLYWAY_URL=${SPRING_FLYWAY_URL:-}" >> $GITHUB_ENV
          SPRING_FLYWAY_USER=$(get_secret "conexao-de-sorte-database-username"); echo "SPRING_FLYWAY_USER=${SPRING_FLYWAY_USER:-}" >> $GITHUB_ENV
          SPRING_FLYWAY_PASSWORD=$(get_secret "conexao-de-sorte-database-password"); echo "SPRING_FLYWAY_PASSWORD=${SPRING_FLYWAY_PASSWORD:-}" >> $GITHUB_ENV

          JWT_ISSUER=$(get_secret "conexao-de-sorte-jwt-issuer"); echo "JWT_ISSUER=${JWT_ISSUER:-}" >> $GITHUB_ENV
          CORS_ALLOWED_ORIGINS=$(get_secret "conexao-de-sorte-cors-allowed-origins"); echo "CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-}" >> $GITHUB_ENV
          CORS_ALLOW_CREDENTIALS=$(get_secret "conexao-de-sorte-cors-allow-credentials"); echo "CORS_ALLOW_CREDENTIALS=${CORS_ALLOW_CREDENTIALS:-true}" >> $GITHUB_ENV

      - name: ğŸ§¹ Cleanup existing deployment
        run: |
          # Remove stack existente se houver
          docker stack rm conexao-auditoria-compliance 2>/dev/null || true
          
          # Aguardar limpeza completa
          echo "â³ Aguardando limpeza completa..."
          sleep 15
          
          # Limpar containers Ã³rfÃ£os do serviÃ§o auditoria-compliance
          docker container ls -q --filter "name=auditoria-compliance" | xargs -r docker stop
          docker container ls -aq --filter "name=auditoria-compliance" | xargs -r docker rm
          
          echo "âœ… Limpeza concluÃ­da"

      - name: Deploy via docker service (update/create)
        run: |
          set -euo pipefail
          IMAGE="${{ needs.build-image.outputs.image-uri }}"
          SERVICE_NAME="${{ env.SERVICE_NAME }}"
          PORT=8096
          NETWORK_NAME="conexao-network-swarm"

          # Criar rede se nÃ£o existir
          docker network create --driver overlay "$NETWORK_NAME" 2>/dev/null || true

          echo "ğŸ” Verificando se serviÃ§o $SERVICE_NAME jÃ¡ existe..."
          if docker service ls --format '{{.Name}}' | grep -qx "$SERVICE_NAME"; then
            echo "ğŸ”„ ServiÃ§o jÃ¡ existe - executando UPDATE para nova imagem"
            timeout 60s docker service update \
              --image "$IMAGE" \
              --detach=false \
              --update-parallelism 1 \
              --update-delay 10s \
              "$SERVICE_NAME"
          else
            echo "ğŸ†• ServiÃ§o nÃ£o existe - executando CREATE"
            timeout 120s docker service create \
              --name "$SERVICE_NAME" \
              --image "$IMAGE" \
              --network "$NETWORK_NAME" \
              --detach=false \
              --publish ${PORT}:8085 \
              --secret source=REDIS_HOST,target=REDIS_HOST \
              --secret source=REDIS_PORT,target=REDIS_PORT \
              --secret source=REDIS_PASSWORD,target=REDIS_PASSWORD \
              --secret source=REDIS_DATABASE,target=REDIS_DATABASE \
              --secret source=JWT_SECRET,target=JWT_SECRET \
              --secret source=JWT_ISSUER,target=JWT_ISSUER \
              --env SPRING_PROFILES_ACTIVE=prod,azure \
              --env TZ=America/Sao_Paulo \
              --env SERVER_PORT=8085 \
              --env SPRING_DATA_REDIS_HOST="${REDIS_HOST:-}" \
              --env SPRING_DATA_REDIS_PORT="${REDIS_PORT:-6379}" \
              --env SPRING_DATA_REDIS_DATABASE="${REDIS_DATABASE:-1}" \
              --env SPRING_R2DBC_URL="${SPRING_R2DBC_URL:-}" \
              --env SPRING_FLYWAY_URL="${SPRING_FLYWAY_URL:-}" \
              --env SPRING_FLYWAY_USER="${SPRING_FLYWAY_USER:-}" \
              --env SPRING_FLYWAY_PASSWORD="${SPRING_FLYWAY_PASSWORD:-}" \
              --env JWT_ISSUER="${JWT_ISSUER:-}" \
              --env CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS:-}" \
              --env CORS_ALLOW_CREDENTIALS="${CORS_ALLOW_CREDENTIALS:-true}" \
              --env AZURE_CLIENT_ID="${{ secrets.AZURE_CLIENT_ID }}" \
              --env AZURE_TENANT_ID="${{ secrets.AZURE_TENANT_ID }}" \
              --env AZURE_KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" \
              --env AZURE_KEYVAULT_ENABLED=true \
              "$SERVICE_NAME"
          fi

          # Verificar se deploy foi bem-sucedido
          echo "âœ… Verificando saÃºde do serviÃ§o..."
          sleep 10
          REPLICAS=$(docker service ls --filter name="$SERVICE_NAME" --format '{{.Replicas}}' | head -1 || echo "")
          if echo "$REPLICAS" | grep -q "1/1"; then
            echo "âœ… Deploy bem-sucedido!"
          else
            echo "âŒ Falha no deploy - verificar logs"
            docker service logs "$SERVICE_NAME" --tail 50 || true
            exit 1
          fi

      - name: Aguardar Auditoria Compliance estar pronto
        run: |
          echo "â³ Aguardando Auditoria Compliance ficar pronto..."
          TIMEOUT=180
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if docker service ls | grep -q "auditoria-compliance.*1/1"; then
              echo "âœ… Auditoria Compliance estÃ¡ pronto!"
              break
            fi
            echo "â³ Aguardando readiness... ($ELAPSED/$TIMEOUT segundos)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ Auditoria Compliance nÃ£o ficou pronto em $TIMEOUT segundos"
            echo "ğŸ“‹ Status dos serviÃ§os:"
            docker service ls | grep auditoria-compliance || true
            echo "ğŸ“‹ Logs do Auditoria Compliance:"
            docker service logs conexao-auditoria-compliance_auditoria-compliance --tail 50 || true
            exit 1
          fi

      - name: Healthâ€‘check Auditoria Compliance
        run: |
          echo "ğŸ” Verificando saÃºde do Auditoria Compliance..."
          docker service ls | grep auditoria-compliance
          
          # Teste do endpoint de health
          SERVICE_CONTAINER=$(docker ps --filter "name=auditoria-compliance" --format "{{.Names}}" | head -1 || echo "")
          if [ -n "$SERVICE_CONTAINER" ]; then
            echo "ğŸŒ Testando health endpoint..."
            docker exec "$SERVICE_CONTAINER" curl -f http://localhost:8085/actuator/health 2>/dev/null && echo "âœ… Auditoria Compliance health OK" || echo "âš ï¸ Auditoria Compliance health test failed"
          fi
          
          echo "ğŸ‰ Auditoria Compliance microservice deployment completed successfully!"
          echo "ğŸŒ API: https://auditoria-compliance.conexaodesorte.com.br"

      - name: "ğŸ§¹ Limpar recursos temporÃ¡rios e otimizar sistema"
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "ğŸ§¹ Limpando recursos temporÃ¡rios..."
          echo "ğŸ—‘ï¸ Limpando imagens antigas nÃ£o utilizadas..."
          docker image prune -af --filter "until=24h" || true
          echo "ğŸ—‘ï¸ Limpando containers parados..."
          docker container prune -f || true
          echo "ğŸ—‘ï¸ Limpando redes Ã³rfÃ£s..."
          docker network prune -f || true
          echo "ğŸ—‘ï¸ Limpando volumes Ã³rfÃ£os (apenas nÃ£o nomeados)..."
          docker volume prune -f --filter "label!=keep" || true
          echo "âœ… Limpeza concluÃ­da"

# ----------------------------------------------------------------------
# JOB 5 â–¸ NOTIFY
# ----------------------------------------------------------------------

  notify:
    if: always()
    runs-on: ubuntu-latest
    needs: [ build-test-scan, deploy-selfhosted ]
    steps:
      - name: Slack notify
        env:
          WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          RESULT: ${{ needs.deploy-selfhosted.result }}
        shell: bash
        run: |
          if [ -z "$WEBHOOK" ]; then
            echo "â„¹ï¸ Slack webhook nÃ£o configurado; etapa ignorada" && exit 0
          fi
          COLOR=good && [ "$RESULT" != "success" ] && COLOR=danger
          curl -X POST -H 'Content-type: application/json' \
               --data "{\"text\":\"Auditoria Compliance â€“ $RESULT\",\"attachments\":[{\"color\":\"$COLOR\"}]}" \
               "$WEBHOOK"

# ----------------------------------------------------------------------
# JOB 6 â–¸ DIAGNÃ“STICO EM CASO DE FALHA
# ----------------------------------------------------------------------

  diagnostics:
    if: failure() && needs.deploy-selfhosted.result == 'failure'
    needs: [deploy-selfhosted]
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-backend-auditoria-compliance ]
    timeout-minutes: 10
    steps:
      - name: "ğŸ©º DiagnÃ³stico detalhado do ambiente (Auditoria/Compliance)"
        shell: bash
        run: |
          echo "ğŸ©º Executando diagnÃ³stico do ambiente de produÃ§Ã£o..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“… Data/Hora: $(date)"
          echo "ğŸ–¥ï¸  Uptime: $(uptime)"
          echo "ğŸ’½ EspaÃ§o em disco:"
          df -h / || true
          echo ""
          echo "ğŸ³ ESTADO DO DOCKER:"
          echo "VersÃ£o Docker: $(docker version --format '{{.Server.Version}}' 2>/dev/null || echo 'N/A')"
          docker info 2>/dev/null | head -20 || echo "Erro ao obter info do Docker"
          echo ""
          echo "ğŸ•¸ï¸  SERVIÃ‡OS DOCKER SWARM:"
          docker service ls 2>/dev/null || echo "Erro ao listar serviÃ§os"
          echo ""
          echo "ğŸ” DETALHES DO SERVIÃ‡O AUDITORIA/COMPLIANCE:"
          SERVICE_NAME="auditoria-compliance"
          if docker service ls | grep -q "$SERVICE_NAME"; then
            echo "Status do serviÃ§o ($SERVICE_NAME):"
            docker service ps "$SERVICE_NAME" --no-trunc 2>/dev/null || true
            echo ""
            echo "Logs do serviÃ§o (Ãºltimas 100 linhas):"
            docker service logs "$SERVICE_NAME" --tail 100 2>/dev/null || true
          else
            echo "âŒ ServiÃ§o $SERVICE_NAME nÃ£o encontrado"
          fi
          echo ""
          echo "ğŸŒ REDES DO PROJETO:"
          docker network ls | grep conexao || echo "Redes do projeto nÃ£o encontradas"
          echo ""
          echo "ğŸ“ˆ USO DE RECURSOS:"
          echo "MemÃ³ria:"
          free -h 2>/dev/null || echo "Comando free nÃ£o disponÃ­vel"
          echo "CPU:"
          top -bn1 | head -5 2>/dev/null || echo "Comando top nÃ£o disponÃ­vel"
          echo ""
          echo "ğŸ” DOCKER SECRETS DISPONÃVEIS:"
          docker secret ls 2>/dev/null || echo "Erro ao listar Docker secrets"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… DiagnÃ³stico concluÃ­do"
